sequenceDiagram
    participant Client
    participant OS/Network
    participant Main/ServerStartup
    participant Server (Event Loop)
    participant ConnectionManager
    participant Connection
    participant RequestParser
    participant Router
    participant Handler (e.g., Static)
    participant ResponseWriter

    %% Initialization Phase %%
    Main/ServerStartup->>ServerConfig: Load configuration
    Main/ServerStartup->>Server: Create Server(config)
    Server->>OS/Network: socket() -> listener_fd
    Server->>OS/Network: bind(listener_fd, port)
    Server->>OS/Network: listen(listener_fd)
    Server->>OS/Network: epoll_create() -> epoll_fd
    Server->>OS/Network: epoll_ctl(ADD, listener_fd, EPOLLIN)
    Main/ServerStartup->>Server: run()

    %% Event Loop Waiting %%
    Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS]

    %% Client Connects %%
    Client->>OS/Network: Connect(server_ip, port)
    OS/Network-->>Server: epoll_wait() returns [listener_fd readable]
    Server->>Server: accept_new_connection()
    Server->>OS/Network: accept(listener_fd) -> client_fd
    Server->>ConnectionManager: Create Connection(client_fd)
    ConnectionManager-->>Server: returns Connection* conn
    Server->>OS/Network: epoll_ctl(ADD, client_fd, EPOLLIN)
    Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS]

    %% Client Sends Request %%
    Client->>OS/Network: Send HTTP Request data
    OS/Network-->>Server: epoll_wait() returns [client_fd readable (EPOLLIN)]
    Server->>ConnectionManager: Get Connection(client_fd) -> conn
    Server->>Server: handle_read(conn)
    Server->>OS/Network: read(client_fd, conn->read_buffer)
    Server->>RequestParser: parse(conn)
    RequestParser->>Connection: Update read_buffer, parse_state
    alt Request not fully parsed
        RequestParser-->>Server: Needs more data
        Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS]
    else Request headers/body complete
        RequestParser->>Connection: Populate Request object (conn->request_data)
        RequestParser-->>Server: Request Parsing Complete
        Server->>Router: route(conn->request_data)
        Router->>Connection: Set active_handler type
        Router-->>Server: Handler Determined (e.g., Static)
        Server->>Handler (e.g., Static): handle(conn)

        %% Handler Processing & Response Building %%
        Handler (e.g., Static)->>OS/Network: (If static) open(file) -> static_file_fd
        Handler (e.g., Static)->>Connection: Create Response object (conn->response_data)
        Handler (e.g., Static)->>ResponseWriter: build_headers(conn->response_data, status, headers)
        ResponseWriter->>Connection: Populate conn->response_data
        Handler (e.g., Static)->>ResponseWriter: build_body_info(conn->response_data, file_size)
        Handler (e.g., Static)->>ResponseWriter: getHeadersString(conn->response_data)
        ResponseWriter-->>Handler (e.g., Static): headers_string
        Handler (e.g., Static)->>Connection: Append headers_string to conn->write_buffer
        Handler (e.g., Static)-->>Server: Ready to Write Headers
        Server->>OS/Network: epoll_ctl(MOD, client_fd, EPOLLIN | EPOLLOUT)
    end

    %% Server Sends Response %%
    Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS]
    OS/Network-->>Server: epoll_wait() returns [client_fd writable (EPOLLOUT)]
    Server->>ConnectionManager: Get Connection(client_fd) -> conn
    Server->>Server: handle_write(conn)
    loop While write_buffer has data or file needs sending
        Server->>OS/Network: write(client_fd, conn->write_buffer / file_chunk)
        Server->>Connection: Update write_buffer_offset / file_offset
        alt Write buffer empty AND file sending not complete
            Server->>Handler (e.g., Static): generate_response_chunk(conn)
            Handler (e.g., Static)->>OS/Network: read(static_file_fd, chunk)
            Handler (e.g., Static)->>Connection: Append chunk to conn->write_buffer
        else Write would block (EAGAIN/EWOULDBLOCK)
            Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS, waiting for EPOLLOUT again]
            break Loop
        end
    end
    Server->>Handler (e.g., Static): Response Complete
    Handler (e.g., Static)->>OS/Network: (If static) close(static_file_fd)

    %% Connection Teardown / Keep-Alive %%
    alt Keep-Alive Requested & Allowed
        Server->>Connection: Reset state for next request (clear buffers, delete Req/Resp)
        Server->>OS/Network: epoll_ctl(MOD, client_fd, EPOLLIN)
        Server->>OS/Network: epoll_wait(epoll_fd) [BLOCKS]
    else Close Connection
        Server->>ConnectionManager: Close Connection(conn)
        ConnectionManager->>OS/Network: epoll_ctl(DEL, client_fd)
        ConnectionManager->>OS/Network: close(client_fd)
        ConnectionManager->>Connection: delete conn (calls ~Connection)
        Note right of ConnectionManager: Destructor cleans up<br/>Request/Response objects.
    end

    Client->>OS/Network: Receive Response Data